![Ironhack Logo](https://i.imgur.com/1QgrNNw.png)

# REST API Express

## Learning Goals
After this lesson, you will be able to:

* Define a model for your application using `mongoose`.
* Build the routes of at REST API using `express`.

## REST overview

**RE**presentational **S**tate **T**ransfer is an architecture which describes how network resources are accessed.

The main features are:
- State and functionality are divided into distributed resources
- Every resource is uniquely addressable using a uniform and minimal set of commands (typically using HTTP verbs GET, POST, PUT, or DELETE over the internet)
- The protocol is client/server and stateless

This architecture makes the interaction between a client and a server easier with a well-defined API. Resources are manipulated using HTTP methods like POST, GET, PUT, and DELETE.

![](https://s3-eu-west-1.amazonaws.com/ih-materials/uploads/upload_4856fefbcbf1801762370434d1357648.png)

Resources are organized like a filesystem, we can navigate into it by adding parameters to the URL, while using different verbs for our HTTP requests.

Let's take a **todo list as an example** of a resource. REST architecture for todos would follow this pattern:


|URL | HTTP verb | Request body | Action |
|-----|----------|-----------|--------|
| `/api/todos` | GET | (empty) | Returns all todos |
| `/api/todos` | POST | JSON | Creates a new todo |
| `/api/todos/:id` | GET | (empty) | Returns a single todo |
| `/api/todos/:id` | PUT | JSON | Edits the todo |
| `/api/todos/:id` | DELETE | (empty) | Deletes the todo |


## Build the API: Phone Store

Our backend will provide an API to access our resources. For this purpose we'll build a phone store, where each phone will have these fields:

- id
- brand
- name
- image
- specs

We will follow REST design to provide access to these phone store resources. In the following section we'll see how to structure our database and define the routes to access the resources.

### Setup

#### Dependencies
For this lesson we need some dependencies installed:

- mongo
- mongoose
- express
- express-generator

#### Express server

We will use the **Ironhack Generator** to build our project.

From the terminal run:

```
$ irongenerate phone-store
```

the generator should create a new folder and give us a fresh starting point to build our API.

```
create dir  : phone-store/bin
create dir  : phone-store/models
create dir  : phone-store/public/images
create dir  : phone-store/public/javascripts
create dir  : phone-store/public/stylesheets
create dir  : phone-store/routes
create dir  : phone-store/views
create dir  : phone-store/.vscode
create file : phone-store/.vscode/launch.json
create file : phone-store/public/stylesheets/style.scss
create file : phone-store/.env
create file : phone-store/.gitignore
create file : phone-store/bin/www
create file : phone-store/routes/index.js
create file : phone-store/views/index.hbs
create file : phone-store/views/layout.hbs
create file : phone-store/views/error.hbs
create file : phone-store/views/not-found.hbs
create file : phone-store/public/images/favicon.ico
create file : phone-store/public/javascripts/script.js
create file : phone-store/package.json
create file : phone-store/app.js

Start your app in development mode:
  $ SET DEBUG=phone-store:* & npm run dev

  Start your app in development mode:
  $ SET DEBUG=phone-store:* & npm run dev

  Start your app:
  $ npm start

  Happy Coding ❤️

```

If everything is fine we should be able to run `npm run dev` from within the project folder. Browsing to `localhost:3000` we can see the autogenerated view:

![](https://s3-eu-west-1.amazonaws.com/ih-materials/uploads/upload_a404b524e8208474cec63baa7ce9aa4d.png)


### Define the model

We now have a mongo database and a server running and connecting to it. We now need to define our `mongoose` schema to handle our `phone` resource.

Let's add a `models/phone-model.js` file as:

```javascript
'use strict';

const mongoose = require('mongoose');

const phoneSchema = new mongoose.Schema({
  brand: {
    type: String,
    required: [true, 'The phone brand is required']
  },
  name: {
    type: String,
    required: [true, 'The phone name is required']
  },
  image: {
    type: String, default: ''
  },
  specs: {
    type: Array,
    default: []
  }
});

const Phone = mongoose.model('Phone', phoneSchema);

module.exports = Phone;
```

We added our main fields `brand`, `name`, `image` and `specs`. Mongo will automatically add an autogenerate unique `id` field, so we don't need to specify it.

### Define the routes

#### API

Adopting the REST architecture, we will provide the following routes in our API:

|URL | HTTP verb | Request body | Action |
|-----|----------|-----------|--------|
| `/api/phones` | GET | (empty) | Returns all the phones |
| `/api/phones` | POST | JSON | Add a new phone |
| `/api/phones/:id` | GET | (empty) | Returns the specified phone |
| `/api/phones/:id` | PUT | JSON | Edits the specified phone |
| `/api/phones/:id` | DELETE | (empty) | Deletes the specified phone |

#### Configure the server

In the `routes` folder we already have an autogenerated example of a route called `users`.

We can delete the `users.js` file and create a new file called `routes/phones-api.js` and define our routes in here.

In the `app.js` we need to replace the old reference to `users` to the new `/api`.

Import the file and assign the routes to the url `/api` by replacing the old references to `users` with:

```javascript
...
var phonesApi = require('./routes/phones-api');
...
app.use('/api', phonesApi);
...
```

We're now ready to implement our API.

#### GET and POST

We'll starting defining the first GET route for the collection of phones:

```javascript
var express = require('express');
var router = express.Router();

const Phone = require('../models/phone-model');

/* GET Phones listing. */
router.get('/phones', (req, res, next) => {
  Phone.find()
  .then(phonesList => {
    if (err) {
      res.json(err);
      return;
    }
    res.json(phonesList);
  })
  .catch(error => next(error))
});

module.exports = router;
```

Let's break it down:
1. We get a `Phone` mongoose reference to operate on the `phones` collection (line #4)
2. In the `GET` we use the `find` method without parameters to retrieve all the phones (lines #7 and #8)
3. We return the list as a JSON if there's no error (line #13)
4. We export the router configuration for the `app.js` file (line #17)

Now let's dive into our `POST` to create a new phone. Right before the export line add a second route:

```javascript
/* CREATE a new Phone. */
router.post('/phones', (req, res, next) => {
  const thePhone = new Phone({
    brand: req.body.brand,
    name: req.body.name,
    specs: req.body.specs,
    image: req.body.image || ''
  });

  thePhone.save()
  .then(thePhone => {
    res.json({
      message: 'New Phone created!',
      id: thePhone._id
    });
  })
  .catch(error => next(error))
});
```

Here we used the body parameters in the request to create a new resource and the `save` method to actually save it to the database.

#### Test with Postman

We defined our first 2 routes, let's test them before moving on.

We can use [Postman](https://www.getpostman.com/) or [Insomnia](https://insomnia.rest/) for this purpose.

Let's open it, with our server and database running, and let's send a POST request to the `localhost:3000/api/phones` url with the body:

```json
{
  "brand": "Nokia",
  "name": "3310",
  "specs": [
    "two months battery life",
    "indestructable"
  ]
}
```

If everything is fine we should get the response:

```json
{
  "message": "New Phone created!",
  "id": "587fec3eaf7b8a1a404b3a6a"
}
```

Now that we have an entry in the database, we can test the `GET` request to the same `localhost:3000/phones` endpoint. The result should be:

```json
[
  {
    "_id": "587fec3eaf7b8a1a404b3a6a",
    "name": "3330",
    "brand": "Nokia",
    "__v": 0,
    "specs": [
      "two months battery life",
      "undestructable"
    ],
    "image": ""
  }
]
```

The result is an array of one element. The phone does have an autogenerated `_id` field and a `__v` field. The second one is called a [`revision field`](http://mongoosejs.com/docs/guide.html#versionKey) and it shows if an item has just been created (i.e. when `__v === 0`).

#### Complete the API

Now that we validated our first two routes, let's complete the REST API:

```javascript
...

/* GET a single Phone. */
router.get('/phones/:id', (req, res, next) => {
  if(!mongoose.Types.ObjectId.isValid(req.params.id)) {
    res.status(400).json({ message: 'Specified id is not valid' });
    return;
  }

  Phone.findById(req.params.id)
  .then(thePhone => {
      res.json(thePhone);
  })
  .catch(error => next(error))
});

/* EDIT a Phone. */
router.put('/phones/:id', (req, res, next) => {
  if(!mongoose.Types.ObjectId.isValid(req.params.id)) {
    res.status(400).json({ message: 'Specified id is not valid' });
    return;
  }

  const updates = {
    brand: req.body.brand,
    name: req.body.name,
    specs: req.body.specs,
    image: req.body.image
  };

  Phone.findByIdAndUpdate(req.params.id, updates)
  .then(phone => {
    res.json({
      message: 'Phone updated successfully'
    });
  }) 
  .catch(error => next(error))     
})

/* DELETE a Phone. */
router.delete('/phones/:id', (req, res, next) => {
  if(!mongoose.Types.ObjectId.isValid(req.params.id)) {
    res.status(400).json({ message: 'Specified id is not valid' });
    return;
  }

  Phone.remove({ _id: req.params.id })
  .then(message => {
    return res.json({
      message: 'Phone has been removed!'
    });
  })
  .catch(error => next(error))
});

...
```

Nothing fancy here, we just use 3 built-in methods of Mongoose to do what we need:
- `findById` to get the specified phone
- `findByIdAndUpdate` to update the specified phone
- `remove` to delete the specified phone

## Enable CORS requests

We know we'll use this API for requests coming from a different application. For development, we will use the angular-cli embedded expressjs server, which runs on a different port - `4200` instead of `3000`. By default, browsers block this kind of communication for security reasons, so we need to configure our server in order to allow them.

Luckily there's a small [node module](https://github.com/expressjs/cors) that helps us allowing [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)

Install it with:

```
$ npm install cors
```

And in `app.js`, import it and use it right after the `express()` function call:

```javascript
...

var cors = require('cors');

var app = express();

app.use(cors());

...
```

## Load some data

We're going to consume this API in the next lesson, and in order to have some data to play with, we've provided a `JSON` file [to download](https://s3-eu-west-1.amazonaws.com/ih-materials/learning-units/rest-api-express-phones.json) to import into mongodb.

Let's first clean up our phones collection, from the mongo shell:

```
$ > use phone-store
$ switched to db phone-store
$ > db.phones.remove({})
$ WriteResult({ "nRemoved" : 1 })
$ > exit
```

Then just run:

```
$ mongoimport --db phone-store --collection phones --file ./rest-api-express-phones.json --jsonArray
```

adapting the `phones.json` location (the default command will work if you put the JSON file in the root folder of the project). This will insert some phones into our database.

If everything works fine, we should see something like:

```
2017-01-30T09:56:27.662+0000	connected to: localhost
2017-01-30T09:56:27.663+0000	imported 3 documents
```

## Summary

In this lesson, we have learned how to define a model for your application using Mongoose, how to build a REST API to provide access to the resources, and how to test our APIs using Postman.

## Extra Resources
- [REpresentational State Transfer](https://en.wikipedia.org/wiki/Representational_state_transfer) - Wikipedia
- [Express generator](http://expressjs.com/en/starter/generator.html) - Express
- [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) - Mozilla Developer Network
